---
title: Dynamic Programming
category: algorithm
tags: dp
---

Top-Down와 Bottom-Up
동적 계획법의 구현은 크게 Top-Down방식과 Bottom-Up방식으로 나뉘어집니다. 
Top-Down방식은 큰 문제에서 작은 부분문제를 재귀적으로 호출하여 리턴 되는 값을 이용하여 큰 문제를 해결하는 방식입니다. 
중복되는 부분문제를 피하기 위해 앞서 소개한 Memoization기법을 함께 사용하며, 위에서 다룬 피보나치 함수의 구현방법 또한 이에 속합니다.

반대로 Bottom-Up방식은 작은 부분문제들을 미리 계산해두고, 이 부분문제들을 모아 큰 문제를 해결하는 방식입니다. 일반적으로 배열에 값을 채워나가는 형태로 구현합니다. 피보나치 함수를 Bottom-Up 방식으로 구현하면 아래와 같습니다.

두 가지 방법은 각각의 장단점이 있습니다. 
Top-Down방식의 경우, 재귀함수를 통해 구현되므로 함수 호출에 대한 오버헤드가 발생합니다. 
반면 Bottom-Up방식의 경우 반복문을 통해 구현되므로 이러한 자원에 비교적 자유로워 시간 및 메모리의 최적화가 쉽습니다.
하지만 Bottom-Up방식의 경우 큰 문제를 해결하기까지 어떠한 sub-problem이 요구되는지 알 수 없으므로 전체 문제를 계산하기위해 모든 부분문제를 해결해야 합니다.
하지만 Top-Down방식의 경우 큰 문제를 해결하기 위해 필요한 sub-problem만을 호출하므로 필요한 부분만 계산하게 되어 특정한 경우에는 Bottom-Up방식보다 빠르게 동작할 수 있습니다.


C[N] = {1, 5, 12}, D[i]: ‘i원을 만들기 위해 필요한 동전의 최소개수’라고 정의합시다. 
우리는 D[K]에 대해 아래와 같은 점화식을 세울 수 있습니다.

            D[K] = Mini=0 to N-1, K > C[i](D[K - C[i]]) + 1

위 식은 K원을 만들기 위해서는 K보다 작은 금액에 새로운 동전이 더해지는 원리입니다. 
더해지는 새로운 동전의 금액이 C[i]라면 D[K](K원을 만들기 위해 필요한 동전의 최소개수)의 후보값은 N개의 금액에 대해서 D[K - C[i]]((K - C[i])원을 만들기 위해 필요한 동전의 최소개수)에 C[i]원 동전 하나를 추가하는 방법들이 될 것입니다.
이는 결국 D[K]라는 큰 문제를 D[K - C[i]]라는 sub-problem으로 나누어 풀게 되는 동적 계획법이 됩니다.

![https://t1.daumcdn.net/cfile/tistory/2270AC3757C44DFD3E](https://t1.daumcdn.net/cfile/tistory/2270AC3757C44DFD3E)
